package main

import (
	"reflect"
)

type nodeType int

const (
	statement nodeType = iota
	assign
	operate
	variable
	constant
	root
)

type tree struct {
	nodes []*tree
	group nodeType
	value string
}

//inStringArray checks if a value is in an array
func inStringArray(val string, array []string) bool {
	for _, currentVal := range array {
		if val == currentVal {
			return true
		}
	}
	return false
}

//acceptTokenValue checks if a token's value matches any strings in an array
//if the array is empty
//	it is assumed there are no constraints on the tokens value,
//	and this function returns true.
func acceptTokenValue(val string, array []string) bool {
	if len(array) == 0 {
		return true
	}
	return inStringArray(val, array)
}

//splitParse gets an array of tokens
//	splits it into segments seperated by tokens that satisfy both toSplit and tokenValues
//	generates a new subnode for each segment (using subNodeType)
//	and runs parser on each of these segments
//splitParse returns root, after subnodes have been added
func splitParse(toSplit tokenType, subNodeType nodeType, tokens []token, root tree, tokenValues ...string) tree {
	lastSplit := -1
	for i, currentToken := range tokens {
		if currentToken.group == toSplit && acceptTokenValue(currentToken.value, tokenValues) {
			subNode := tree{group: subNodeType, value: currentToken.value}
			root.nodes = append(root.nodes, &subNode)
			subNode = parser(tokens[lastSplit+1:i], subNode)
			lastSplit = i
		}
	}

	return root
}

//parser parses an array of tokens, generated by tokenizer, into an AST.
//This AST can then be used to either generate machine code or direct execution.
//This function recursively calls itself to build the AST.
//The second argument to parser specifies the initial node
func parser(tokens []token, root tree) tree {
	//whenever parser is recursively called, it must have exclusive access to root tree
	//this function can be optimized, as it currently iterates through tokens when not needed,
	//	as a side effect of recursion

	//seperate into statements
	statementTree := splitParse(statementDelim, statement, tokens, root)
	if !reflect.DeepEqual(statementTree, root) {
		return statementTree
	}

	//seperate into assignment
	assignmentTree := splitParse(assignment, assign, tokens, root)
	if !reflect.DeepEqual(assignmentTree, root) {
		return assignmentTree
	}

	//at this point, we could optionally check for a well formed statement tree

	//parse mathematical operators
	muldivTree := splitParse(operator, operate, tokens, root, "*", "/")
	if !reflect.DeepEqual(muldivTree, root) {
		return muldivTree
	}
	addsubTree := splitParse(operator, operate, tokens, root, "+", "-")
	if !reflect.DeepEqual(addsubTree, root) {
		return addsubTree
	}

	//parse names and numbers
	nameTree := splitParse(name, variable, tokens, root)
	if !reflect.DeepEqual(nameTree, root) {
		return nameTree
	}
	numTree := splitParse(number, constant, tokens, root)
	if !reflect.DeepEqual(numTree, root) {
		return numTree
	}

	return root
}
